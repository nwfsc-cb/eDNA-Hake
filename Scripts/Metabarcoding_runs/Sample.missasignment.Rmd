---
title: "Comparing indices performance"
output: html_notebook
---
Asuming that the tag jumping itself has not changed between Nextera and the UDIs, we can estimate the proportion of reads that actually jumpued in this scenario. We can also check the proportion of reads that jumped to nearby indices (likely to be a droplet), to indices with closely related sequences (PCR performance) or randomly to a different index (pure jump).

```{r}
library (tidyverse)
library (ape)
library (insect)

```


```{r}
samples_run <- read_csv("~/Projects/eDNA-Hake/Data/test_samples_UDI.csv")

read_csv("~/Projects/Nextera_Dada2/data_sub/Dual_indices_Adapters.csv") -> ADAPTERS

ADAPTERS %>% 
  select(I7_Index_ID = Index,
         Well_target = Well,
         Set) %>% 
  separate(Well_target, into = c("row_target", "col_target"), sep = 1, remove = F, convert = T) %>% 
  mutate( row_target = as.numeric(as.factor(row_target))) -> Adapters 
```

Calculate the euclidean distance in a plate 

```{r}
samples_run %>% 
  separate(Index_Plate_Well, into = c("row_origin", "col_origin"), sep = 1, remove = F, convert = T) %>% 
  mutate( row_origin = as.numeric(as.factor(row_origin))) %>% 
  left_join(Adapters) %>% 
    mutate(distance = pmap_dbl(.l = list(a = row_origin,
                                   b = col_origin,
                                   c = row_target,
                                   d = col_target), 
                         .f = function(a,b,c,d){
                           r1 = c(a,b)
                           r2 = c(c,d)
                           dist (rbind(r1,r2))
                         })) -> step1

all.indices <- ADAPTERS %>% 
  filter (Set %in% c(1,2)) %>% 
  select(Index, Bases_in_Adapter_i7)

all.indices$Bases_in_Adapter_i7 -> indices
names(indices) <- all.indices$Index
as_tibble(reshape2::melt(as.matrix(dist.dna(char2dna(indices), model = "raw")))) -> dna.dist.udis

step1 %>% 
  left_join(dna.dist.udis, by = c("I7_Index_ID" = "Var1", "I5_Index_ID" ="Var2")) %>% 
  rename (dna.dist = value) -> all.distances

all.distances %>% 
  mutate (corrected.distance = case_when(Set == Index_Plate ~ distance,
                                         TRUE               ~ 50)) -> all.distances

```

In bash, use wc -l to calculate the number of sequences on each fastq file - and write it out to a report file

```{bash}

wc -l /Volumes/Universal/Run20201119b/*_R1_001.fastq > /Volumes/Universal/Run20201119b/read.counts.txt

```

Polish the results
```{r}
nreads <- read_delim ("/Volumes/Universal/Run20201119b/read.counts.txt", delim = " ",col_names = c("lines", "sample"))

nreads %>% 
  mutate (nseq = as.numeric(lines)/4) %>% 
  mutate (file = str_remove(sample,"/Volumes/Universal/Run20201119b/" )) %>% 
  mutate (file = str_remove(file, "_L001_R1_001.fastq")) %>% 
  select(file, nseq) -> nreads

nreads %>% 
  write_csv("~/Projects/Nextera_Dada2/data_sub/read.counts.csv")

all.distances %>% 
  unite(Sample_Name, Sample_ID, sep = "_S", col = "file",remove = F) %>% 
  left_join(nreads) -> all.distances

```

```{r}
all.distances %>% 
  separate(Index_Plate_Well, into = "Row", sep = 1) %>% 
  filter (str_detect(file, "Crosscut")) %>% 
  ggplot(aes(x = col_origin,
             y = Row, 
             fill = nseq)) +
  geom_raster()+
  scale_x_discrete()+
   scale_y_discrete(limits = rev(levels(~Row)))+
  facet_grid (I7_Index_ID ~ Index_Plate)
```

